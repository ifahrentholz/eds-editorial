{"version":3,"file":"fetch.service.7cfQZ1Bx.js","sources":["../../src/app/utils/getUrlForEndpoint.ts","../../src/utils/RuntimeCache.ts","../../src/services/fetch.service.ts"],"sourcesContent":["export const getUrlForEndpoint = (endpoint: string): URL => {\n  // TODO: do we really need to use window.hlx.codeBasePath here?\n  const baseUrl = new URL(window.hlx.codeBasePath, window.location.origin);\n  return new URL(endpoint, baseUrl);\n};\n","export class RuntimeCache {\n  private runtimeCache: Map<string, any> = new Map();\n\n  public get<T>(key: string): T | undefined {\n    return this.runtimeCache.get(key);\n  }\n\n  public set<T>(key: string, value: T): void {\n    this.runtimeCache.set(key, value);\n  }\n\n  public has(key: string): boolean {\n    return this.runtimeCache.has(key);\n  }\n\n  public delete(key: string): void {\n    this.runtimeCache.delete(key);\n  }\n}\n","import { getUrlForEndpoint } from '../app/utils/getUrlForEndpoint';\nimport { RuntimeCache } from '../utils/RuntimeCache';\n\nexport interface FetchServiceCacheOptions {\n  cacheType?: 'runtime'; // 'local' | 'session' | \"request\" can be added later\n}\n\nexport interface FetchServiceOptions {\n  fetchOptions?: RequestInit;\n  cacheOptions?: FetchServiceCacheOptions;\n}\n\nclass FetchService {\n  private requestPipeline: Map<string, Promise<Response>> = new Map();\n\n  private runtimeCache = new RuntimeCache();\n\n  public fetchJson<T>(endpoint: string, options: FetchServiceOptions = {}): Promise<T> {\n    return this.fetchData(getUrlForEndpoint(endpoint).href, options, this.getResponseJSON<T>);\n  }\n\n  public fetchText(endpoint: string, options: FetchServiceOptions = {}): Promise<string> {\n    return this.fetchData(getUrlForEndpoint(endpoint).href, options, this.getResponseText);\n  }\n\n  private async fetchData<T>(\n    url: string,\n    options: FetchServiceOptions,\n    dataMapper: (Response) => Promise<T>\n  ): Promise<T> {\n    const { cacheOptions } = options;\n    const cachedData = this.getCachedData<T>(url, cacheOptions);\n    if (cachedData !== null) return cachedData;\n\n    const pipelinedRequest = this.requestPipeline.get(url);\n    if (pipelinedRequest !== undefined) return dataMapper(await pipelinedRequest);\n\n    const request = fetch(url, options.fetchOptions);\n    this.requestPipeline.set(url, request);\n\n    const response = await request;\n    this.requestPipeline.delete(url);\n    const responseData = await dataMapper(response);\n\n    this.setCachedData(url, responseData, cacheOptions);\n    return responseData;\n  }\n\n  private async getResponseJSON<T>(response: Response): Promise<T> {\n    const responseClone = response.clone();\n    const responseJson = await responseClone.json();\n    return responseJson;\n  }\n\n  private async getResponseText(response: Response): Promise<string> {\n    const responseClone = response.clone();\n    const responseText = await responseClone.text();\n    return responseText;\n  }\n\n  private getCachedData<T>(url: string, cacheOptions?: FetchServiceCacheOptions): T | null {\n    if (cacheOptions?.cacheType === 'runtime') {\n      return this.runtimeCache.get(url) ?? null;\n    }\n    return null;\n  }\n\n  private setCachedData<T>(url: string, data: T, cacheOptions?: FetchServiceCacheOptions): void {\n    if (cacheOptions?.cacheType === 'runtime') {\n      this.runtimeCache.set(url, data);\n    }\n  }\n}\n\nexport default new FetchService();\n"],"names":["getUrlForEndpoint","endpoint","baseUrl","RuntimeCache","key","value","FetchService","options","url","dataMapper","cacheOptions","cachedData","pipelinedRequest","request","response","responseData","data","FetchService$1"],"mappings":"AAAa,MAAAA,EAAqBC,GAA0B,CAEpD,MAAAC,EAAU,IAAI,IAAI,OAAO,IAAI,aAAc,OAAO,SAAS,MAAM,EAChE,OAAA,IAAI,IAAID,EAAUC,CAAO,CAClC,ECJO,MAAMC,CAAa,CAAnB,aAAA,CACG,KAAA,iBAAqC,GAAI,CAE1C,IAAOC,EAA4B,CACjC,OAAA,KAAK,aAAa,IAAIA,CAAG,CAClC,CAEO,IAAOA,EAAaC,EAAgB,CACpC,KAAA,aAAa,IAAID,EAAKC,CAAK,CAClC,CAEO,IAAID,EAAsB,CACxB,OAAA,KAAK,aAAa,IAAIA,CAAG,CAClC,CAEO,OAAOA,EAAmB,CAC1B,KAAA,aAAa,OAAOA,CAAG,CAC9B,CACF,CCNA,MAAME,CAAa,CAAnB,aAAA,CACU,KAAA,oBAAsD,IAEtD,KAAA,aAAe,IAAIH,CAAa,CAEjC,UAAaF,EAAkBM,EAA+B,GAAgB,CAC5E,OAAA,KAAK,UAAUP,EAAkBC,CAAQ,EAAE,KAAMM,EAAS,KAAK,eAAkB,CAC1F,CAEO,UAAUN,EAAkBM,EAA+B,GAAqB,CAC9E,OAAA,KAAK,UAAUP,EAAkBC,CAAQ,EAAE,KAAMM,EAAS,KAAK,eAAe,CACvF,CAEA,MAAc,UACZC,EACAD,EACAE,EACY,CACN,KAAA,CAAE,aAAAC,CAAiB,EAAAH,EACnBI,EAAa,KAAK,cAAiBH,EAAKE,CAAY,EAC1D,GAAIC,IAAe,KAAa,OAAAA,EAEhC,MAAMC,EAAmB,KAAK,gBAAgB,IAAIJ,CAAG,EACrD,GAAII,IAAqB,OAAkB,OAAAH,EAAW,MAAMG,CAAgB,EAE5E,MAAMC,EAAU,MAAML,EAAKD,EAAQ,YAAY,EAC1C,KAAA,gBAAgB,IAAIC,EAAKK,CAAO,EAErC,MAAMC,EAAW,MAAMD,EAClB,KAAA,gBAAgB,OAAOL,CAAG,EACzB,MAAAO,EAAe,MAAMN,EAAWK,CAAQ,EAEzC,YAAA,cAAcN,EAAKO,EAAcL,CAAY,EAC3CK,CACT,CAEA,MAAc,gBAAmBD,EAAgC,CAGxD,OADc,MADCA,EAAS,QACU,MAE3C,CAEA,MAAc,gBAAgBA,EAAqC,CAG1D,OADc,MADCA,EAAS,QACU,MAE3C,CAEQ,cAAiBN,EAAaE,EAAmD,CACnF,OAAAA,GAAA,YAAAA,EAAc,aAAc,UACvB,KAAK,aAAa,IAAIF,CAAG,GAAK,KAEhC,IACT,CAEQ,cAAiBA,EAAaQ,EAASN,EAA+C,EACxFA,GAAA,YAAAA,EAAc,aAAc,WACzB,KAAA,aAAa,IAAIF,EAAKQ,CAAI,CAEnC,CACF,CAEA,MAAeC,EAAA,IAAIX"}