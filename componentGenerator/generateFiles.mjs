/// <reference path="./types/types.d.ts"/>
// @ts-check
'use strict';

import fs from 'fs';
import path from 'node:path';
import util from 'util';
import chalk from 'chalk';
import inquirer from 'inquirer';
import { mkdirp } from 'mkdirp';

// for getting confirmation regarding overriding of existing files, ask user in cli
// shouldn't be used for example when files are generated by a project scaffolding scripts,
// or tests
let useInquirer = false;

/**
 * generates a file with the given content at the given path,
 * if the file already exist, the user will be asked to override or skip this file generation
 *
 * @param {string} filename - filename for the new file
 * @param {string} content - content of the new file
 * @async
 */
async function generateFile(filename, content) {
  const filePath = path.resolve(filename);

  if (await fileExist(filePath)) {
    try {
      await getPermission(filePath);
    } catch {
      // no permission --> don't modify file
      return;
    }
  }
  try {
    await writeFile(filePath, content);
    console.log(chalk.green('âœ“ ' + filePath) + ' was generated!');
  } catch (err) {
    console.log(chalk.red('X ' + filePath), " file couldn't be created :( ", err);
  }
}

/**
 * generates a new file at the given path and with the given content
 *
 * @param {string} filePath - path for the the file
 * @param {string} content - content of the new file
 * @async
 */
async function writeFile(filePath, content) {
  const asyncWriteFile = util.promisify(fs.writeFile);
  await mkdirp(path.dirname(filePath));
  await asyncWriteFile(filePath, content);
}

/**
 * changes the first letter of the given text to uppercase
 *
 * @param {string} name - name
 * @returns {string}
 */
function firstLetterToUpperCase(name) {
  return name.charAt(0).toUpperCase() + name.substring(1);
}

/**
 * changes the first letter of the given text to lowercase
 *
 * @param {string} name - name
 * @returns {string}
 */
function firstLetterToLowerCase(name) {
  return name.charAt(0).toLowerCase() + name.substring(1);
}

/**
 * checks if for the given file path a file exists
 *
 * @param {*} filePath - path of the file to check if exist
 * @returns {Promise<Boolean>}
 */
function fileExist(filePath) {
  return new Promise((resolve, _reject) => {
    fs.open(filePath, 'r', (err, _fd) => {
      if (err) {
        resolve(false);
      } else {
        resolve(true);
      }
    });
  });
}

/**
 * if in interactive mode, the user will be asked in the cli if the file should be overridden
 * in non interactive mode, permission is always granted.
 *
 * @param {string} filename - name of the file which needs permission to be overridden
 * @returns {Promise<void>}
 */
function getPermission(filename) {
  if (!useInquirer) return Promise.resolve();

  return new Promise(async (resolve, reject) => {
    console.log(chalk.gray(filename) + ' already ' + chalk.red('exist') + '.');
    const answers = await inquirer.prompt([
      // override
      {
        type: 'list',
        name: 'override',
        message: 'should it be overwritten?',
        choices: ['skip', 'override'],
      },
    ]);

    if (answers.override === 'override') {
      // permission to override file was granted
      resolve();
    } else {
      reject();
    }
  });
}

/**
 * generates boilerplate files for a new components according to the provided options
 *
 * @param {GenerateComponent.Options} options - options for the creation of the new components necessary files
 * @param {GenerateComponent.Config} config - configuration for files to be genared based on the options
 * @param {boolean} [isInteractive=false] - should the user be asked in the CLI when new information / permission is needed.
 *                                          Otherwise it assumes always the permission to be granted
 * @async
 */
export default async function generateFiles(options, config, isInteractive = false) {
  useInquirer = Boolean(isInteractive);

  const { name } = options;

  // e.g. "related content" -> "Related Topics"
  const uppercase = name.split(' ').map(firstLetterToUpperCase).join(' ');
  // e.g. "RelatedTopics"
  const pascalCase = uppercase.replace(/ /g, '');
  // e.g. "relatedTopics"
  const camelCase = firstLetterToLowerCase(pascalCase);
  // e.g. "related-topics"
  const kebabCase = name.split(' ').join('-');

  /**
   * @type {GenerateComponent.TemplateOptions}
   */
  const templateOptions = Object.assign({}, options, {
    uppercase,
    pascalCase,
    camelCase,
    kebabCase,
  });

  for (const item of config) {
    // files
    if (item.files) {
      for (const file of item.files) {
        if (
          (typeof file.when === 'function' && file.when(options)) ||
          (typeof file.when === 'boolean' && file.when) ||
          (typeof file.when === 'undefined' && true)
        ) {
          await generateFile(file.path(templateOptions), await file.template(templateOptions));
        }
      }
    }
  }
}
