// eslint-disable-next-line spaced-comment
/// <reference path="./types/types.d.ts"/>
import path from 'node:path';

const COMPONENTS_DIR = 'src/components';
const BLOCKS_DIR = 'src/blocks';
const TEMPLATES_DIR = 'componentGenerator/templates';

const COMPONENT_TYPES = {
  BLOCK: 'Block',
  COMPONENT: 'Component',
};

/**
 * returns the template function from the user or the default templates if the user did not override it
 *
 * @param {string} filename - template filename
 * @returns {function}
 */
async function getTemplate(filename, { templatesDir = TEMPLATES_DIR } = {}) {
  let template;

  try {
    template = await import(path.resolve(`${templatesDir}/${filename}.mjs`));
  } catch (_error) {
    // user did not provide a template, use the default one
    template = await import(`./templates/${filename}`);
  }

  return template;
}

/**
 * default configuration for the questions and files which are generated by `generate-component`
 * @type {GenerateComponent.Config}
 */
export default [
  // Component Name
  {
    id: 'NAME',
    prompt: {
      name: 'name',
      type: 'input',
      message: "What's the component's name?:",
      validate(value) {
        // only letters and numbers. (no special characters such as '-' and '_')
        const pass = value.match(/(^[a-zA-Z0-9 ]+$)/g);
        if (pass) {
          return true;
        }

        return 'Please enter only letters, numbers and spaces';
      },
      filter(name) {
        // " Related Topics " -> "related topics"
        return (
          name
            .trim()
            .toLowerCase()
            // only one empty space between letters is allowed
            .replace(/ ( )+/g, ' ')
        );
      },
    },
  },
  // type
  {
    id: 'TYPE',
    prompt: {
      name: 'type',
      type: 'list',
      message: 'Type?',
      choices: [COMPONENT_TYPES.BLOCK, COMPONENT_TYPES.COMPONENT],
    },
  },
  // scss
  {
    id: 'SCSS',
    files: [
      {
        id: 'SCSS-FILE',
        template: async (options) => {
          const template = await getTemplate('scssTemplate', options);
          return await template.default(options);
        },
        path: (options) =>
          `${options.type === COMPONENT_TYPES.COMPONENT ? COMPONENTS_DIR : BLOCKS_DIR}/${options.kebabCase}/${options.kebabCase}.scss`,
      },
    ],
  },
  // markdown
  {
    id: 'MD',
    files: [
      {
        id: 'MD-FILE',
        template: async (options) => {
          const template = await getTemplate('mdTemplate', options);
          return await template.default(options);
        },
        path: (options) =>
          `${options.type === COMPONENT_TYPES.COMPONENT ? COMPONENTS_DIR : BLOCKS_DIR}/${options.kebabCase}/${options.kebabCase}.md`,
      },
    ],
  },
  // ts
  {
    id: 'TS',
    files: [
      {
        id: 'TS-FILE',
        template: async (options) => {
          const template = await getTemplate(
            options.type === COMPONENT_TYPES.COMPONENT ? 'tsTemplateComponent' : 'tsTemplateBlock',
            options
          );
          return await template.default(options);
        },
        path: (options) =>
          `${options.type === COMPONENT_TYPES.COMPONENT ? COMPONENTS_DIR : BLOCKS_DIR}/${options.kebabCase}/${options.kebabCase}.ts`,
      },
    ],
  },
];
